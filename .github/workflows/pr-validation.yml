name: PR Validation & Quality Checks

# This workflow validates PRs against project standards and coding guidelines
# It runs on every PR to ensure code quality, documentation, and best practices

on:
  pull_request:
    types: [opened, synchronize, reopened, edited]
    branches:
      - cms
      - master
      - develop

permissions:
  contents: read
  pull-requests: write
  checks: write

jobs:
  pr-validation:
    runs-on: ubuntu-latest
    name: Validate PR Standards

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'
          cache-dependency-path: yarn.lock

      - name: Setup Yarn
        run: |
          corepack enable
          yarn install --frozen-lockfile

      - name: Validate Branch Naming
        id: branch-validation
        run: |
          BRANCH_NAME="${{ github.head_ref }}"
          echo "Branch name: $BRANCH_NAME"
          
          # Check branch naming pattern
          if [[ "$BRANCH_NAME" =~ ^(feat|feature|fix|bugfix|break|breaking|hotfix|chore|docs|style|refactor|test)/[a-zA-Z0-9._-]+$ ]]; then
            echo "‚úÖ Branch name follows conventions: $BRANCH_NAME"
            echo "branch_valid=true" >> $GITHUB_OUTPUT
            
            # Determine expected version type
            if [[ "$BRANCH_NAME" =~ ^(feat|feature)/ ]]; then
              echo "expected_version=minor" >> $GITHUB_OUTPUT
            elif [[ "$BRANCH_NAME" =~ ^(break|breaking)/ ]]; then
              echo "expected_version=major" >> $GITHUB_OUTPUT
            elif [[ "$BRANCH_NAME" =~ ^(fix|bugfix|hotfix|docs|style|refactor|test|chore)/ ]]; then
              echo "expected_version=patch" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ùå Branch name doesn't follow conventions: $BRANCH_NAME"
            echo "branch_valid=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate PR Title
        id: pr-title-validation
        run: |
          PR_TITLE="${{ github.event.pull_request.title }}"
          echo "PR Title: $PR_TITLE"
          
          # Check conventional commit format
          if [[ "$PR_TITLE" =~ ^(feat|fix|docs|style|refactor|test|chore|break)(\(.+\))?!?:\ .+ ]]; then
            echo "‚úÖ PR title follows conventional commits"
            echo "title_valid=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå PR title should follow conventional commits format"
            echo "title_valid=false" >> $GITHUB_OUTPUT
          fi
          
          # Check title length
          if [ ${#PR_TITLE} -le 72 ]; then
            echo "‚úÖ PR title length appropriate (${#PR_TITLE} chars)"
            echo "title_length_valid=true" >> $GITHUB_OUTPUT
          else
            echo "‚ùå PR title too long (${#PR_TITLE} chars, max 72)"
            echo "title_length_valid=false" >> $GITHUB_OUTPUT
          fi

      - name: Validate PR Description
        id: pr-description-validation
        run: |
          PR_BODY="${{ github.event.pull_request.body }}"
          
          if [ -z "$PR_BODY" ] || [ "$PR_BODY" = "null" ]; then
            echo "‚ùå PR description is empty"
            echo "description_valid=false" >> $GITHUB_OUTPUT
          elif [ ${#PR_BODY} -lt 20 ]; then
            echo "‚ùå PR description too short (${#PR_BODY} chars, min 20)"
            echo "description_valid=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ PR description provided (${#PR_BODY} chars)"
            echo "description_valid=true" >> $GITHUB_OUTPUT
          fi

      - name: Code Quality Checks
        id: code-quality
        run: |
          echo "Running code quality checks..."
          
          # ESLint
          if yarn run --help | grep -q "lint"; then
            echo "Running ESLint..."
            if yarn lint; then
              echo "‚úÖ ESLint passed"
              echo "eslint_valid=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå ESLint failed"
              echo "eslint_valid=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è No lint script found"
            echo "eslint_valid=true" >> $GITHUB_OUTPUT
          fi
          
          # TypeScript type checking
          if yarn run --help | grep -q "type-check"; then
            echo "Running TypeScript checks..."
            if yarn type-check; then
              echo "‚úÖ TypeScript checks passed"
              echo "typescript_valid=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå TypeScript checks failed"
              echo "typescript_valid=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è No type-check script found"
            echo "typescript_valid=true" >> $GITHUB_OUTPUT
          fi

      - name: Test Coverage
        id: test-validation
        continue-on-error: true
        run: |
          echo "Running tests..."
          
          if yarn run --help | grep -q "test"; then
            if yarn test; then
              echo "‚úÖ Tests passed"
              echo "tests_valid=true" >> $GITHUB_OUTPUT
            else
              echo "‚ùå Tests failed"
              echo "tests_valid=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚ö†Ô∏è No test script found"
            echo "tests_valid=true" >> $GITHUB_OUTPUT
          fi

      - name: Check File Changes
        id: file-validation
        run: |
          echo "Analyzing changed files..."
          
          # Get changed files
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}..HEAD)
          echo "Changed files:"
          echo "$CHANGED_FILES"
          
          # Check for TypeScript/JavaScript files
          TS_JS_FILES=$(echo "$CHANGED_FILES" | grep -E '\.(ts|tsx|js|jsx)$' || true)
          
          if [ -n "$TS_JS_FILES" ]; then
            echo "‚úÖ Code files detected, full validation required"
            echo "code_changes=true" >> $GITHUB_OUTPUT
            
            # Check for console.log
            if git diff origin/${{ github.base_ref }}..HEAD | grep -E '^\+.*console\.(log|warn|error)'; then
              echo "‚ùå console.log statements found in new code"
              echo "console_logs=true" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ No console.log statements in new code"
              echo "console_logs=false" >> $GITHUB_OUTPUT
            fi
            
            # Check for TODO/FIXME without issues
            if git diff origin/${{ github.base_ref }}..HEAD | grep -E '^\+.*TODO|FIXME' | grep -v '#[0-9]'; then
              echo "‚ùå TODO/FIXME without issue references found"
              echo "todos_without_issues=true" >> $GITHUB_OUTPUT
            else
              echo "‚úÖ No unlinked TODO/FIXME comments"
              echo "todos_without_issues=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ Only non-code files changed"
            echo "code_changes=false" >> $GITHUB_OUTPUT
            echo "console_logs=false" >> $GITHUB_OUTPUT
            echo "todos_without_issues=false" >> $GITHUB_OUTPUT
          fi

      - name: Documentation Validation
        id: docs-validation
        run: |
          CHANGED_FILES=$(git diff --name-only origin/${{ github.base_ref }}..HEAD)
          
          # Check if README or docs were updated for new features
          if echo "$CHANGED_FILES" | grep -E 'src/.*\.(ts|tsx)$' && [[ "${{ github.head_ref }}" =~ ^(feat|feature)/ ]]; then
            if echo "$CHANGED_FILES" | grep -E '(README|\.md)$'; then
              echo "‚úÖ Documentation updated with new feature"
              echo "docs_updated=true" >> $GITHUB_OUTPUT
            else
              echo "‚ö†Ô∏è New feature without documentation update"
              echo "docs_updated=false" >> $GITHUB_OUTPUT
            fi
          else
            echo "‚úÖ Documentation requirements met"
            echo "docs_updated=true" >> $GITHUB_OUTPUT
          fi

      - name: Generate Validation Report
        uses: actions/github-script@v7
        with:
          script: |
            const results = {
              branch_valid: '${{ steps.branch-validation.outputs.branch_valid }}' === 'true',
              title_valid: '${{ steps.pr-title-validation.outputs.title_valid }}' === 'true',
              title_length_valid: '${{ steps.pr-title-validation.outputs.title_length_valid }}' === 'true',
              description_valid: '${{ steps.pr-description-validation.outputs.description_valid }}' === 'true',
              eslint_valid: '${{ steps.code-quality.outputs.eslint_valid }}' === 'true',
              typescript_valid: '${{ steps.code-quality.outputs.typescript_valid }}' === 'true',
              tests_valid: '${{ steps.test-validation.outputs.tests_valid }}' === 'true',
              console_logs: '${{ steps.file-validation.outputs.console_logs }}' === 'true',
              todos_without_issues: '${{ steps.file-validation.outputs.todos_without_issues }}' === 'true',
              docs_updated: '${{ steps.docs-validation.outputs.docs_updated }}' === 'true',
              code_changes: '${{ steps.file-validation.outputs.code_changes }}' === 'true'
            };

            const branchName = '${{ github.head_ref }}';
            const prTitle = '${{ github.event.pull_request.title }}';
            const expectedVersion = '${{ steps.branch-validation.outputs.expected_version }}';

            let status = '‚úÖ **PASSED**';
            let blocking = false;
            
            const issues = [];
            const warnings = [];

            // Critical issues (blocking)
            if (!results.branch_valid) {
              issues.push('‚ùå Branch name must follow pattern: `type/description` (feat/, fix/, docs/, etc.)');
              blocking = true;
            }
            
            if (!results.title_valid) {
              issues.push('‚ùå PR title must follow conventional commits: `type: description`');
              blocking = true;
            }
            
            if (!results.description_valid) {
              issues.push('‚ùå PR description is required (minimum 20 characters)');
              blocking = true;
            }
            
            if (!results.eslint_valid) {
              issues.push('‚ùå ESLint validation failed - fix linting errors');
              blocking = true;
            }
            
            if (!results.typescript_valid) {
              issues.push('‚ùå TypeScript validation failed - fix type errors');
              blocking = true;
            }
            
            if (!results.tests_valid) {
              issues.push('‚ùå Tests are failing - ensure all tests pass');
              blocking = true;
            }

            // Code quality issues (blocking for code changes)
            if (results.code_changes) {
              if (results.console_logs) {
                issues.push('‚ùå Remove console.log statements from production code');
                blocking = true;
              }
              
              if (results.todos_without_issues) {
                issues.push('‚ùå TODO/FIXME comments must reference GitHub issues (#123)');
                blocking = true;
              }
            }

            // Warnings (non-blocking)
            if (!results.title_length_valid) {
              warnings.push('‚ö†Ô∏è PR title is longer than 72 characters');
            }
            
            if (!results.docs_updated && branchName.startsWith('feat')) {
              warnings.push('‚ö†Ô∏è Consider updating documentation for new features');
            }

            if (blocking) {
              status = '‚ùå **FAILED**';
            } else if (warnings.length > 0) {
              status = '‚ö†Ô∏è **PASSED WITH WARNINGS**';
            }

            // Generate report
            let report = `## üîç PR Validation Report

            **Status:** ${status}
            **Branch:** \`${branchName}\`
            **Expected Version Bump:** \`${expectedVersion || 'patch'}\`

            ---

            ### ‚úÖ Validation Results

            | Check | Status | Description |
            |-------|--------|-------------|
            | **Branch Naming** | ${results.branch_valid ? '‚úÖ Pass' : '‚ùå Fail'} | Must follow \`type/description\` pattern |
            | **PR Title** | ${results.title_valid ? '‚úÖ Pass' : '‚ùå Fail'} | Must follow conventional commits |
            | **PR Description** | ${results.description_valid ? '‚úÖ Pass' : '‚ùå Fail'} | Required, minimum 20 characters |
            | **ESLint** | ${results.eslint_valid ? '‚úÖ Pass' : '‚ùå Fail'} | Code style and quality rules |
            | **TypeScript** | ${results.typescript_valid ? '‚úÖ Pass' : '‚ùå Fail'} | Type checking validation |
            | **Tests** | ${results.tests_valid ? '‚úÖ Pass' : '‚ùå Fail'} | All tests must pass |`;

            if (results.code_changes) {
              report += `
            | **Code Quality** | ${!results.console_logs && !results.todos_without_issues ? '‚úÖ Pass' : '‚ùå Fail'} | No console.log, TODOs need issues |
            | **Documentation** | ${results.docs_updated ? '‚úÖ Pass' : '‚ö†Ô∏è Warning'} | Updated for new features |`;
            }

            if (issues.length > 0) {
              report += `

            ### ‚ùå Issues to Fix

            ${issues.map(issue => `- ${issue}`).join('\n')}`;
            }

            if (warnings.length > 0) {
              report += `

            ### ‚ö†Ô∏è Warnings

            ${warnings.map(warning => `- ${warning}`).join('\n')}`;
            }

            report += `

            ---

            ### üìã Coding Standards Checklist

            - [ ] Code follows TypeScript best practices
            - [ ] No \`any\` types used (prefer specific types)
            - [ ] Single quotes used consistently
            - [ ] \`const\` used by default, \`let\` only when reassigning
            - [ ] No unused variables or imports
            - [ ] Proper error handling implemented
            - [ ] JSDoc comments for public APIs
            - [ ] Tests added/updated for changes
            - [ ] No deep relative imports (\`../../../\`)

            ### üéØ Next Steps

            ${blocking ? 
              '**This PR is blocked** - please fix the issues above before it can be merged.' : 
              '**This PR is ready for review** - all validation checks passed!'
            }

            ${expectedVersion ? `
            ### üì¶ Expected Release Impact
            
            Based on branch name \`${branchName}\`, this PR will trigger a **${expectedVersion}** version bump when merged.` : ''}

            ---
            
            *This validation runs automatically on every PR. Questions? Check our [Contributing Guidelines](./CONTRIBUTING.md)*`;

            // Post comment
            const { data: comments } = await github.rest.issues.listComments({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
            });

            const botComment = comments.find(comment => 
              comment.user.type === 'Bot' && 
              comment.body.includes('üîç PR Validation Report')
            );

            if (botComment) {
              await github.rest.issues.updateComment({
                comment_id: botComment.id,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: report
              });
            } else {
              await github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: report
              });
            }

            // Set status check
            if (blocking) {
              core.setFailed('PR validation failed - please fix the issues above');
            }